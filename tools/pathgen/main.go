// pathgen generates api/paths.go from the Neper OpenAPI/Swagger spec.
//
// Usage:
//
//	go run ./tools/pathgen -spec dependencies/neper/neper-api.yaml -output api/paths.go
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

// SwaggerSpec represents the relevant parts of a Swagger 2.0 spec.
type SwaggerSpec struct {
	Paths map[string]PathItem `yaml:"paths"`
}

// PathItem represents a path with its operations.
type PathItem struct {
	Parameters []Parameter `yaml:"parameters"`
	Get        *Operation  `yaml:"get"`
	Post       *Operation  `yaml:"post"`
	Put        *Operation  `yaml:"put"`
	Delete     *Operation  `yaml:"delete"`
}

// Operation represents an HTTP operation.
type Operation struct {
	OperationID string      `yaml:"operationId"`
	Parameters  []Parameter `yaml:"parameters"`
}

// Parameter represents a path/query parameter.
type Parameter struct {
	Name     string `yaml:"name"`
	In       string `yaml:"in"`
	Type     string `yaml:"type"`
	Required bool   `yaml:"required"`
}

// PathInfo holds processed path information for code generation.
type PathInfo struct {
	Template   string      // Original path template e.g. "/v1/sessions/{session_id}/join"
	Resource   string      // Resource name e.g. "Sessions", "Invitations"
	FuncName   string      // Generated function name e.g. "SessionJoinPath"
	Parameters []ParamInfo // Path parameters
	IsConstant bool        // Whether this generates a constant
	ConstName  string      // Constant name if IsConstant
	Verb       string      // HTTP verb (get, post, put, delete) - used for naming
}

// ParamInfo holds processed parameter information.
type ParamInfo struct {
	Name   string // Original name e.g. "session_id"
	GoName string // Go variable name e.g. "sessionID"
	GoType string // Go type e.g. "string", "int"
}

// Known compound words that should be split for proper PascalCase
var compoundWords = map[string]string{
	"userinfo": "user_info",
	"apikey":   "api_key",
}

func main() {
	specPath := flag.String("spec", "dependencies/neper/neper-api.yaml", "Path to swagger spec")
	outputPath := flag.String("output", "api/paths.go", "Output file path")
	flag.Parse()

	spec, err := parseSpec(*specPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing spec: %v\n", err)
		os.Exit(1)
	}

	code, err := generate(spec, *specPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error generating code: %v\n", err)
		os.Exit(1)
	}

	if err := os.WriteFile(*outputPath, code, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing output: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s\n", *outputPath)
}

func parseSpec(path string) (*SwaggerSpec, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("reading file: %w", err)
	}

	var spec SwaggerSpec
	if err := yaml.Unmarshal(data, &spec); err != nil {
		return nil, fmt.Errorf("parsing YAML: %w", err)
	}

	return &spec, nil
}

func generate(spec *SwaggerSpec, specPath string) ([]byte, error) {
	paths := processPathsFromSpec(spec)

	var buf bytes.Buffer

	// Header
	buf.WriteString("// Code generated by tools/pathgen; DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "// Source: %s\n\n", specPath)
	buf.WriteString("package api\n\n")
	buf.WriteString("import \"fmt\"\n\n")

	// Write constants
	writeConstants(&buf, paths)

	// Write functions grouped by resource
	writeFunctions(&buf, paths)

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("formatting code: %w", err)
	}

	return formatted, nil
}

func processPathsFromSpec(spec *SwaggerSpec) []PathInfo {
	var paths []PathInfo
	seen := make(map[string]bool)

	for pathTemplate := range spec.Paths {
		// Skip health check
		if pathTemplate == "/healthz" {
			continue
		}
		if seen[pathTemplate] {
			continue
		}
		seen[pathTemplate] = true

		pathItem := spec.Paths[pathTemplate]

		// Determine the primary verb for this path (for naming purposes)
		// Priority: DELETE > PUT > POST > GET (DELETE is most specific for naming)
		verb := determinePrimaryVerb(pathItem)

		info := processPath(pathTemplate, pathItem, verb)
		paths = append(paths, info)
	}

	// Sort for consistent output
	sort.Slice(paths, func(i, j int) bool {
		// Constants first, then by resource, then by name
		if paths[i].IsConstant != paths[j].IsConstant {
			return paths[i].IsConstant
		}
		if paths[i].Resource != paths[j].Resource {
			return paths[i].Resource < paths[j].Resource
		}
		name1 := paths[i].FuncName
		if name1 == "" {
			name1 = paths[i].ConstName
		}
		name2 := paths[j].FuncName
		if name2 == "" {
			name2 = paths[j].ConstName
		}
		return name1 < name2
	})

	return paths
}

// determinePrimaryVerb returns the verb to use for naming purposes.
// Only returns "delete" when DELETE is the ONLY operation on the path,
// to disambiguate from paths that have GET+DELETE (same resource).
func determinePrimaryVerb(pathItem PathItem) string {
	opCount := 0
	if pathItem.Get != nil {
		opCount++
	}
	if pathItem.Post != nil {
		opCount++
	}
	if pathItem.Put != nil {
		opCount++
	}
	if pathItem.Delete != nil {
		opCount++
	}

	// Only use "delete" for naming when it's the sole operation
	if pathItem.Delete != nil && opCount == 1 {
		return "delete"
	}

	// Otherwise, use a neutral verb (won't affect naming)
	return ""
}

func processPath(template string, pathItem PathItem, verb string) PathInfo {
	// Collect path parameters
	params := collectPathParameters(pathItem)

	// Remove /v1 prefix for processing
	cleanPath := strings.TrimPrefix(template, "/v1/")
	segments := strings.Split(cleanPath, "/")

	// Determine resource (first segment)
	resource := ""
	if len(segments) > 0 {
		resource = toPascalCase(segments[0])
	}

	// Check if this is a constant (no path parameters)
	isConstant := len(params) == 0

	// Only use verb for naming if path ends with a parameter (resource ID),
	// not an action word like "approve" or "reject"
	useVerbForNaming := verb != "" && len(segments) > 0 &&
		strings.HasPrefix(segments[len(segments)-1], "{")

	var info PathInfo
	info.Template = template
	info.Resource = resource
	info.Parameters = params
	info.IsConstant = isConstant
	info.Verb = verb

	if isConstant {
		// Check if this is a WebSocket endpoint (use Path suffix instead of Base)
		isWebSocket := isWebSocketEndpoint(pathItem)
		info.ConstName = buildConstName(segments, isWebSocket)
	} else {
		effectiveVerb := ""
		if useVerbForNaming {
			effectiveVerb = verb
		}
		info.FuncName = buildFuncName(segments, effectiveVerb)
	}

	return info
}

func collectPathParameters(pathItem PathItem) []ParamInfo {
	var params []ParamInfo
	seen := make(map[string]bool)

	// Collect from path-level parameters
	for _, p := range pathItem.Parameters {
		if p.In == "path" && !seen[p.Name] {
			seen[p.Name] = true
			params = append(params, ParamInfo{
				Name:   p.Name,
				GoName: toGoParamName(p.Name),
				GoType: toGoType(p.Type),
			})
		}
	}

	// Collect from operations
	ops := []*Operation{pathItem.Get, pathItem.Post, pathItem.Put, pathItem.Delete}
	for _, op := range ops {
		if op == nil {
			continue
		}
		for _, p := range op.Parameters {
			if p.In == "path" && !seen[p.Name] {
				seen[p.Name] = true
				params = append(params, ParamInfo{
					Name:   p.Name,
					GoName: toGoParamName(p.Name),
					GoType: toGoType(p.Type),
				})
			}
		}
	}

	return params
}

// Known sub-collection words that should get a Base suffix
var subCollectionWords = map[string]bool{
	"sent": true,
}

// isWebSocketEndpoint checks if a path is a WebSocket endpoint by looking at the operation summary
func isWebSocketEndpoint(pathItem PathItem) bool {
	if pathItem.Get != nil && pathItem.Get.OperationID != "" {
		// Check common WebSocket indicators in summary or description
		// The operationId "notifications" and similar are WebSocket endpoints
		opID := strings.ToLower(pathItem.Get.OperationID)
		if opID == "notifications" {
			return true
		}
	}
	return false
}

func buildConstName(segments []string, isWebSocket bool) string {
	// Single segment paths
	if len(segments) == 1 {
		name := toPascalCase(segments[0])
		// WebSocket endpoints get Path suffix instead of Base
		if isWebSocket {
			return name + "Path"
		}
		return name + "Base"
	}

	// Multi-segment: determine suffix based on last segment
	lastSeg := segments[len(segments)-1]

	// Build the name parts
	var parts []string

	// For paths like /downloads/stars.exe, singularize the parent
	if strings.Contains(lastSeg, ".") {
		parts = append(parts, toSingular(toPascalCase(segments[0])))
		for i := 1; i < len(segments); i++ {
			parts = append(parts, toPascalCase(segments[i]))
		}
		return strings.Join(parts, "")
	}

	// Regular multi-segment path
	for _, seg := range segments {
		parts = append(parts, toPascalCase(seg))
	}
	name := strings.Join(parts, "")

	// Add Base suffix for sub-collections
	if subCollectionWords[lastSeg] {
		return name + "Base"
	}

	// No suffix for action endpoints
	return name
}

// buildFuncName generates a function name from path segments and HTTP verb.
// Rules:
//  1. First segment (resource) is singularized if path has any parameters
//  2. Other segments are singularized when followed by their ID param
//  3. Add verb suffix for DELETE operations to disambiguate
func buildFuncName(segments []string, verb string) string {
	var nameParts []string

	// Check if path has any parameters (for first segment singularization)
	hasParams := false
	for _, seg := range segments {
		if strings.HasPrefix(seg, "{") {
			hasParams = true
			break
		}
	}

	for i := 0; i < len(segments); i++ {
		seg := segments[i]

		// Skip parameter placeholders
		if strings.HasPrefix(seg, "{") {
			continue
		}

		shouldSingularize := false

		if i == 0 {
			// First segment (resource): singularize if path has any parameters
			shouldSingularize = hasParams
		} else {
			// Other segments: singularize if followed by matching ID parameter
			if i+1 < len(segments) {
				nextSeg := segments[i+1]
				if strings.HasPrefix(nextSeg, "{") && strings.HasSuffix(nextSeg, "}") {
					paramName := nextSeg[1 : len(nextSeg)-1] // Remove { }
					shouldSingularize = isMatchingIDParam(seg, paramName)
				}
			}
		}

		part := toPascalCase(seg)
		if shouldSingularize {
			part = toSingular(part)
		}
		nameParts = append(nameParts, part)
	}

	// Add verb suffix for DELETE to disambiguate from other operations
	if verb == "delete" {
		nameParts = append(nameParts, "Delete")
	}

	return strings.Join(nameParts, "") + "Path"
}

// isMatchingIDParam checks if a param name is the ID param for a segment.
// Examples:
//   - segment "sessions", param "session_id" → true
//   - segment "player_race", param "player_race_id" → true
//   - segment "orders", param "year" → false
func isMatchingIDParam(segment, paramName string) bool {
	// Normalize segment: remove trailing 's' for plural, convert to snake_case base
	// "sessions" → "session", "player_race" → "player_race"
	singular := segment
	if strings.HasSuffix(segment, "s") && !strings.HasSuffix(segment, "ss") {
		singular = segment[:len(segment)-1]
	}

	// Check if param is "{singular}_id" or just "{singular}id"
	expectedID := singular + "_id"
	if paramName == expectedID {
		return true
	}

	// Also check without underscore: "sessionid"
	if paramName == singular+"id" {
		return true
	}

	return false
}

// Resources that need explicit base constants even when no single-segment path exists
var needsBaseConstant = map[string]string{
	"Auth":      "AuthBase",
	"Downloads": "DownloadsBase",
}

func writeConstants(buf *bytes.Buffer, paths []PathInfo) {
	buf.WriteString("// =============================================================================\n")
	buf.WriteString("// BASE PATHS\n")
	buf.WriteString("// =============================================================================\n\n")

	buf.WriteString("const (\n")
	buf.WriteString("\t// Base API path\n")
	buf.WriteString("\tAPIBase = \"/api/v1\"\n\n")

	// Group constants by resource for better organization
	byResource := make(map[string][]PathInfo)
	for _, p := range paths {
		if p.IsConstant {
			byResource[p.Resource] = append(byResource[p.Resource], p)
		}
	}

	// Sort resources
	var resources []string
	for r := range byResource {
		resources = append(resources, r)
	}
	sort.Strings(resources)

	for _, resource := range resources {
		constants := byResource[resource]
		sort.Slice(constants, func(i, j int) bool {
			return constants[i].ConstName < constants[j].ConstName
		})

		fmt.Fprintf(buf, "\t// %s\n", resource)

		// Find base constant (single segment paths)
		var baseConstName string
		for _, c := range constants {
			cleanPath := strings.TrimPrefix(c.Template, "/v1/")
			if !strings.Contains(cleanPath, "/") {
				baseConstName = c.ConstName
				break
			}
		}

		// If no single-segment path but resource needs base constant, create it
		if baseConstName == "" {
			if baseName, needsBase := needsBaseConstant[resource]; needsBase {
				// Get resource lowercase name from first constant
				cleanPath := strings.TrimPrefix(constants[0].Template, "/v1/")
				firstSeg := strings.Split(cleanPath, "/")[0]
				fmt.Fprintf(buf, "\t%s = APIBase + \"/%s\"\n", baseName, firstSeg)
				baseConstName = baseName
			}
		}

		for _, c := range constants {
			cleanPath := strings.TrimPrefix(c.Template, "/v1/")

			if !strings.Contains(cleanPath, "/") {
				// Base path: uses APIBase
				fmt.Fprintf(buf, "\t%s = APIBase + \"/%s\"\n", c.ConstName, cleanPath)
			} else if baseConstName != "" {
				// Sub-path: uses base constant
				// Extract the sub-path portion
				firstSlash := strings.Index(cleanPath, "/")
				subPath := cleanPath[firstSlash:]
				fmt.Fprintf(buf, "\t%s = %s + \"%s\"\n", c.ConstName, baseConstName, subPath)
			} else {
				// No base constant, use APIBase directly
				fmt.Fprintf(buf, "\t%s = APIBase + \"/%s\"\n", c.ConstName, cleanPath)
			}
		}
		buf.WriteString("\n")
	}

	buf.WriteString(")\n\n")
}

func writeFunctions(buf *bytes.Buffer, paths []PathInfo) {
	// Group functions by resource
	byResource := make(map[string][]PathInfo)
	for _, p := range paths {
		if !p.IsConstant {
			byResource[p.Resource] = append(byResource[p.Resource], p)
		}
	}

	// Sort resources
	var resources []string
	for r := range byResource {
		resources = append(resources, r)
	}
	sort.Strings(resources)

	for _, resource := range resources {
		funcs := byResource[resource]
		if len(funcs) == 0 {
			continue
		}

		sort.Slice(funcs, func(i, j int) bool {
			return funcs[i].FuncName < funcs[j].FuncName
		})

		buf.WriteString("// =============================================================================\n")
		fmt.Fprintf(buf, "// %s\n", resource)
		buf.WriteString("// =============================================================================\n\n")

		for _, f := range funcs {
			writeFunction(buf, f, resource)
		}
	}
}

func writeFunction(buf *bytes.Buffer, p PathInfo, resource string) {
	// Build parameter list
	var params []string
	for _, param := range p.Parameters {
		params = append(params, fmt.Sprintf("%s %s", param.GoName, param.GoType))
	}
	paramStr := strings.Join(params, ", ")

	// Find base constant name
	baseConst := resource + "Base"

	// Get the part after the resource
	cleanPath := strings.TrimPrefix(p.Template, "/v1/")
	segments := strings.Split(cleanPath, "/")

	// Build the sprintf format and args
	var formatParts []string
	var args []string
	formatParts = append(formatParts, "%s") // For base constant
	args = append(args, baseConst)

	for i := 1; i < len(segments); i++ {
		seg := segments[i]
		if strings.HasPrefix(seg, "{") && strings.HasSuffix(seg, "}") {
			// Parameter placeholder
			paramName := seg[1 : len(seg)-1]
			// Find the param info
			var paramInfo *ParamInfo
			for j := range p.Parameters {
				if p.Parameters[j].Name == paramName {
					paramInfo = &p.Parameters[j]
					break
				}
			}
			if paramInfo != nil {
				if paramInfo.GoType == "int" {
					formatParts = append(formatParts, "%d")
				} else {
					formatParts = append(formatParts, "%s")
				}
				args = append(args, paramInfo.GoName)
			}
		} else {
			// Static segment
			formatParts = append(formatParts, seg)
		}
	}

	// Build the final format string
	formatStr := strings.Join(formatParts, "/")

	// Write comment
	comment := generateComment(p)
	fmt.Fprintf(buf, "// %s\n", comment)

	// Write function
	fmt.Fprintf(buf, "func %s(%s) string {\n", p.FuncName, paramStr)
	fmt.Fprintf(buf, "\treturn fmt.Sprintf(\"%s\", %s)\n", formatStr, strings.Join(args, ", "))
	buf.WriteString("}\n\n")
}

func generateComment(p PathInfo) string {
	// Extract action from function name
	singular := toSingular(p.Resource)
	action := strings.TrimSuffix(p.FuncName, "Path")
	action = strings.TrimPrefix(action, singular)

	if action == "" {
		return fmt.Sprintf("%s returns the path for a specific %s.", p.FuncName, strings.ToLower(singular))
	}

	readable := camelToSpaces(action)
	return fmt.Sprintf("%s returns the path to %s for a %s.", p.FuncName, readable, strings.ToLower(singular))
}

// Helper functions

func toPascalCase(s string) string {
	// Expand known compound words
	if expanded, ok := compoundWords[strings.ToLower(s)]; ok {
		s = expanded
	}

	// Handle dots as word separators (e.g., "stars.exe" → "stars_exe")
	s = strings.ReplaceAll(s, ".", "_")

	// Handle snake_case
	parts := strings.Split(s, "_")
	var result []string
	for _, part := range parts {
		if part == "" {
			continue
		}
		// Handle known acronyms (but not file extensions like exe)
		upper := strings.ToUpper(part)
		if upper == "AI" || upper == "API" || upper == "ID" || upper == "URL" {
			result = append(result, upper)
		} else {
			result = append(result, strings.ToUpper(part[:1])+part[1:])
		}
	}
	return strings.Join(result, "")
}

func toGoParamName(name string) string {
	// Convert snake_case to camelCase
	parts := strings.Split(name, "_")
	var result []string
	for i, part := range parts {
		if part == "" {
			continue
		}
		if i == 0 {
			// First part is lowercase, but handle "id" specially
			if part == "id" {
				result = append(result, "id")
			} else {
				result = append(result, part)
			}
		} else {
			// Handle known acronyms
			upper := strings.ToUpper(part)
			if upper == "ID" {
				result = append(result, "ID")
			} else {
				result = append(result, strings.ToUpper(part[:1])+part[1:])
			}
		}
	}
	return strings.Join(result, "")
}

func toGoType(swaggerType string) string {
	switch swaggerType {
	case "integer":
		return "int"
	case "boolean":
		return "bool"
	default:
		return "string"
	}
}

func toSingular(s string) string {
	// Handle "ies" → "y" (e.g., "Categories" → "Category")
	if strings.HasSuffix(s, "ies") {
		return s[:len(s)-3] + "y"
	}
	// Handle regular plural "s" (e.g., "Sessions" → "Session")
	if strings.HasSuffix(s, "s") {
		return s[:len(s)-1]
	}
	return s
}

func camelToSpaces(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, ' ')
		}
		result = append(result, r)
	}
	return strings.ToLower(string(result))
}
