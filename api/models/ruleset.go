// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Ruleset a ruleset that will be applied during a session
//
// swagger:model ruleset
type Ruleset struct {

	// Controls the length of the game and STRONGLY recommended.
	//
	// This feature advances the game by "advancing" the start time.
	// Although the game will still start in the year 2400, all players will have built-up
	// some minerals and population with this option.
	// This speeds up the time taken to actually build your first vessels and to make
	// contact with other players.
	// Most players prefer this option.
	//
	AcceleratedBbsPlay bool `json:"accelerated_bbs_play,omitempty" db:"accelerated_bbs_play"`

	// For Advanced players only.
	//
	// Computer players will only attack human players, not other AIs.
	// The effectiveness of this parameter is decided by the number of computer AIs in the game.
	// If you only have one or two, this will not make much of a difference in the game.
	// However, with three or more AIs against Advanced level players, this parameter should definitely
	// be chosen, since Advanced players already know how to beat the AIs hands-down.
	//
	ComputerPlayersFormAlliances bool `json:"computer_players_form_alliances,omitempty" db:"computer_players_form_alliances"`

	// 0: Sparse
	// 1: Normal
	// 2: Dense
	// 3: Packed
	//
	// Maximum: 3
	// Minimum: 0
	Density int64 `json:"density,omitempty" db:"density"`

	// Alters game playing strategy.
	//
	// The clumping of planets switches the focus of the game over from controlling individual worlds,
	// to controlling entire star clusters. This is more realistic.
	// However: Many players dislike the fact that planet names have a tendency to print on top of other names,
	// making it a real pain to quickly locate particular worlds.
	//
	GalaxyClumping bool `json:"galaxy_clumping,omitempty" db:"galaxy_clumping"`

	// This makes every world in the game start with maximum mineral concentrations,
	// extending the game. If players don't have to worry about running out of
	// minerals too soon, they will build their empire and remain relatively comfortable,
	// unless provoked by another player.
	//
	// Note: A lot of players DO NOT like this parameter, being that it is pretty unrealistic
	//
	MaximumMinerals bool `json:"maximum_minerals,omitempty" db:"maximum_minerals"`

	// Evens the flow of the game.
	//
	// This choice eliminates hidden mineral concentrations, the Mystery Trader, meteor impacts,
	// and left-over tech. artifacts.
	// If you want all players to be on an even par throughout the game, this is the item to choose.
	// For pre-genned games: If you plan to start the game later in the timeline,
	// be warned about the possibility of a meteor hitting a player's home-world prior to game start.
	// If this happens, you should immediately re-start the game.
	//
	NoRandomEvents bool `json:"no_random_events,omitempty" db:"no_random_events"`

	// Alters game strategy.
	//
	// If players know who is ahead in the game, they are more likely to immediately ally
	// in order to stop the lead player.
	// This leads to very interesting game play, revolving around alliances and back-stabbing.
	// Not having this option forces players to construct large information gathering infrastructures,
	// in order to ascertain the strengths of their opponents.
	//
	PublicPlayerScores bool `json:"public_player_scores,omitempty" db:"public_player_scores"`

	// The optional Random Seed number forces the universe to be created exactly the same each time, if you use the same Seed number.
	//
	RandomSeed int64 `json:"random_seed,omitempty" db:"random_seed"`

	// Controls the length of the game.
	//
	// This choice doubles the amount of resources necessary to achieve new technology.
	// It gives players more time to utilize their existing technology before new tech. comes along.
	// This usually means that players will build more ships of any particular class,
	// creating dilemmas when their "slots" are full (16 designs).
	// For Beginners: Due to the advanced planning of ship designs (what to build, when to build, how many),
	// a host may not want to use this if designing a game for exclusively beginning level players.
	//
	SlowerTechAdvances bool `json:"slower_tech_advances,omitempty" db:"slower_tech_advances"`

	// 0: Close
	// 1: Moderate
	// 2: Farther
	// 3: Distant
	//
	// Maximum: 3
	// Minimum: 0
	StartingDistance int64 `json:"starting_distance,omitempty" db:"starting_distance"`

	// 0: Tiny
	// 1: Small
	// 2: Medium
	// 3: Large
	// 4: Huge
	//
	// Maximum: 4
	// Minimum: 0
	UniverseSize int64 `json:"universe_size,omitempty" db:"universe_size"`

	// At least "X" years must pass before a winner is declared
	// Simply put, how long do you want the game to go?
	// Remember, one year in the game is usually equivalent to one turn played per day.
	// Selecting 500 years means that the game will last at least 500 days of real time (more likely two full years).
	//
	// Since you are the one running the game and doing all the work,
	// be sure to choose a time frame that you can live with.
	//
	// Maximum: 500
	// Minimum: 30
	VcAtLeastxYearsMustPassBeforeaWinnerIsDeclared int64 `json:"vc_at_least_x_years_must_pass_before_a_winner_is_declared,omitempty" db:"vc_at_least_x_years_must_pass_before_a_winner_is_declared"`

	// Attain Tech "X" in "Y" fields (Balanced strategy)
	// Because tech-level acquisition goes hand in hand with resources,
	// players desiring to meet this condition will angle their race towards more efficient tech production,
	// as well as be encouraged to increase their size in order to harness more resources.
	//
	VcAttainTechXInYField bool `json:"vc_attain_tech_X_in_Y_field,omitempty" db:"vc_attain_tech_x_in_y_field"`

	// number of fields to attain
	// Maximum: 6
	// Minimum: 2
	VcAttainTechXInYFieldFieldsValue int64 `json:"vc_attain_tech_X_in_Y_field_fields_value,omitempty" db:"vc_attain_tech_x_in_y_field_fields_value"`

	// tech value to attain
	// Maximum: 26
	// Minimum: 8
	VcAttainTechXInYFieldTechValue int64 `json:"vc_attain_tech_X_in_Y_field_tech_value,omitempty" db:"vc_attain_tech_x_in_y_field_tech_value"`

	// Exceed the next player's score by "X"% (Offensive strategy)
	// This is perhaps the most popular victory condition, as it forces players to eliminate any opposition.
	// This will create many alliances and politic-ing as lesser empires try to get an edge and
	// chop down the leading players.
	//
	VcExceedNextPlayerScoreByx bool `json:"vc_exceed_next_player_score_by_x,omitempty" db:"vc_exceed_next_player_score_by_x"`

	// Percentage of score you need to have above the next player to score this victory condition.
	// Maximum: 300
	// Minimum: 20
	VcExceedNextPlayerScoreByxValue int64 `json:"vc_exceed_next_player_score_by_x_value,omitempty" db:"vc_exceed_next_player_score_by_x_value"`

	// Exceed a score of "X" (Balanced strategy)
	// Once again, resources are the deciding factor here,
	// forcing a combination of good production efficiency and territory acquisition out of the players.
	//
	// "Hyper-producing" races may run amok in a game like this, scaring the hell out of other players,
	// and causing an early war or two.
	//
	// Players could also win via this condition by manipulating other factors which can effect score,
	// unlike the other victory condition two listings down.
	// Additionally, as with any "total" type requirement, a host should be careful not to place unreal
	// goals on a game that can not fulfil them.
	// Having a higher score as a requirement to win in a small universe may be unattainable altogether.
	//
	VcExceedScoreOfx bool `json:"vc_exceed_score_of_x,omitempty" db:"vc_exceed_score_of_x"`

	// score value to exceed to validate this victory condition.
	// Maximum: 20000
	// Minimum: 1000
	VcExceedScoreOfxValue int64 `json:"vc_exceed_score_of_x_value,omitempty" db:"vc_exceed_score_of_x_value"`

	// Has a production capacity of "X" thousand (Balanced strategy)
	// This is very similar to the score requirement above,
	// but it relies totally on the production of resources.
	// Players will shoot for high production efficiency and conquest of worlds.
	//
	VcHasProductionCapacityOfxThousand bool `json:"vc_has_production_capacity_of_x_thousand,omitempty" db:"vc_has_production_capacity_of_x_thousand"`

	// production value needed to score this victory condition
	// Maximum: 500
	// Minimum: 10
	VcHasProductionCapacityOfxThousandValue int64 `json:"vc_has_production_capacity_of_x_thousand_value,omitempty" db:"vc_has_production_capacity_of_x_thousand_value"`

	// Have the highest score after "X" years
	// Consider this carefully.
	// This is a bonus category which a player can score if they have the highest score any time
	// after the year specified.
	// This parameter should not be used in conjunction with the "Exceed next highest score by "X"%",
	// since it already indicates that the player holding this category is ahead in the game.
	//
	// Because this is a relatively easy category to win, be sure to give other players a chance to win
	// after one player wins this category.
	// It should be used as an incentive to build quickly, but it should not decide the entire chances of victory.
	//
	VcHaveHighestScoreAfterxYears bool `json:"vc_have_highest_score_after_x_years,omitempty" db:"vc_have_highest_score_after_x_years"`

	// Number of years after which this victory condition can be achieved.
	// Maximum: 900
	// Minimum: 30
	VcHaveHighestScoreAfterxYearsValue int64 `json:"vc_have_highest_score_after_x_years_value,omitempty" db:"vc_have_highest_score_after_x_years_value"`

	// Owns "X" capital ships (Defensive strategy)
	// This really lends itself to keeping out of trouble for the player.
	// Even though one can build capital ships, it is another thing to keep them intact in order to win the game.
	// Also, because of the long time necessary in order to achieve the technology to build these ships,
	// games will run a long time.
	//
	VcOwnsxCapitalShips bool `json:"vc_owns_x_capital_ships,omitempty" db:"vc_owns_x_capital_ships"`

	// number of capital ships necessary to validate this victory condition
	// Maximum: 300
	// Minimum: 10
	VcOwnsxCapitalShipsValue int64 `json:"vc_owns_x_capital_ships_value,omitempty" db:"vc_owns_x_capital_ships_value"`

	// Enables the victory condition based on number of planets.
	// If true, you will need to fill the vc_percent_of_planets field
	// with the required percentage for this condition to be true.
	//
	// Owns "X"% of planets (Offensive strategy) -
	// Be carefull how high you put this. Players with restricted habitability ranges will,
	// generally, not be able to own more than 50% of all possible worlds.
	// For the HE: Hyper-expansion will always have the advantage in a game with this victory condition.
	// Perhaps this is one reason why HE is banned from most games.
	//
	VcOwnsxPercentOfPlanets bool `json:"vc_owns_x_percent_of_planets,omitempty" db:"vc_owns_x_percent_of_planets"`

	// required percentage
	// Maximum: 100
	// Minimum: 20
	VcOwnsxPercentOfPlanetsValue int64 `json:"vc_owns_x_percent_of_planets_value,omitempty" db:"vc_owns_x_percent_of_planets_value"`

	// Winner must meet "X" of the above selected criteria
	// Selecting this will give players more than one way to win,
	// if you set "X" to less than the number of selected categories.
	//
	// This will provide more ways to win and lead to interesting strategies that will effect
	// one another as the game progresses.
	//
	// Making players meet the same set of conditions will lead to either a production game,
	// with wars intermittent, or to a conquest game, with rampant death and destruction.
	//
	// Note: It is never wise to select virtually all conditions with every condition needing to be met.
	// This will lead to a game where, once one player firmly establishes a lead,
	// many players will probably cede victory without further play.
	//
	// Maximum: 7
	// Minimum: 0
	VcWinnerMustMeetxOfTheAbove int64 `json:"vc_winner_must_meet_x_of_the_above,omitempty" db:"vc_winner_must_meet_x_of_the_above"`
}

// Validate validates this ruleset
func (m *Ruleset) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDensity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartingDistance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUniverseSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcAtLeastxYearsMustPassBeforeaWinnerIsDeclared(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcAttainTechXInYFieldFieldsValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcAttainTechXInYFieldTechValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcExceedNextPlayerScoreByxValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcExceedScoreOfxValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcHasProductionCapacityOfxThousandValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcHaveHighestScoreAfterxYearsValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcOwnsxCapitalShipsValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcOwnsxPercentOfPlanetsValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcWinnerMustMeetxOfTheAbove(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Ruleset) validateDensity(formats strfmt.Registry) error {
	if swag.IsZero(m.Density) { // not required
		return nil
	}

	if err := validate.MinimumInt("density", "body", m.Density, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("density", "body", m.Density, 3, false); err != nil {
		return err
	}

	return nil
}

func (m *Ruleset) validateStartingDistance(formats strfmt.Registry) error {
	if swag.IsZero(m.StartingDistance) { // not required
		return nil
	}

	if err := validate.MinimumInt("starting_distance", "body", m.StartingDistance, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("starting_distance", "body", m.StartingDistance, 3, false); err != nil {
		return err
	}

	return nil
}

func (m *Ruleset) validateUniverseSize(formats strfmt.Registry) error {
	if swag.IsZero(m.UniverseSize) { // not required
		return nil
	}

	if err := validate.MinimumInt("universe_size", "body", m.UniverseSize, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("universe_size", "body", m.UniverseSize, 4, false); err != nil {
		return err
	}

	return nil
}

func (m *Ruleset) validateVcAtLeastxYearsMustPassBeforeaWinnerIsDeclared(formats strfmt.Registry) error {
	if swag.IsZero(m.VcAtLeastxYearsMustPassBeforeaWinnerIsDeclared) { // not required
		return nil
	}

	if err := validate.MinimumInt("vc_at_least_x_years_must_pass_before_a_winner_is_declared", "body", m.VcAtLeastxYearsMustPassBeforeaWinnerIsDeclared, 30, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("vc_at_least_x_years_must_pass_before_a_winner_is_declared", "body", m.VcAtLeastxYearsMustPassBeforeaWinnerIsDeclared, 500, false); err != nil {
		return err
	}

	return nil
}

func (m *Ruleset) validateVcAttainTechXInYFieldFieldsValue(formats strfmt.Registry) error {
	if swag.IsZero(m.VcAttainTechXInYFieldFieldsValue) { // not required
		return nil
	}

	if err := validate.MinimumInt("vc_attain_tech_X_in_Y_field_fields_value", "body", m.VcAttainTechXInYFieldFieldsValue, 2, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("vc_attain_tech_X_in_Y_field_fields_value", "body", m.VcAttainTechXInYFieldFieldsValue, 6, false); err != nil {
		return err
	}

	return nil
}

func (m *Ruleset) validateVcAttainTechXInYFieldTechValue(formats strfmt.Registry) error {
	if swag.IsZero(m.VcAttainTechXInYFieldTechValue) { // not required
		return nil
	}

	if err := validate.MinimumInt("vc_attain_tech_X_in_Y_field_tech_value", "body", m.VcAttainTechXInYFieldTechValue, 8, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("vc_attain_tech_X_in_Y_field_tech_value", "body", m.VcAttainTechXInYFieldTechValue, 26, false); err != nil {
		return err
	}

	return nil
}

func (m *Ruleset) validateVcExceedNextPlayerScoreByxValue(formats strfmt.Registry) error {
	if swag.IsZero(m.VcExceedNextPlayerScoreByxValue) { // not required
		return nil
	}

	if err := validate.MinimumInt("vc_exceed_next_player_score_by_x_value", "body", m.VcExceedNextPlayerScoreByxValue, 20, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("vc_exceed_next_player_score_by_x_value", "body", m.VcExceedNextPlayerScoreByxValue, 300, false); err != nil {
		return err
	}

	return nil
}

func (m *Ruleset) validateVcExceedScoreOfxValue(formats strfmt.Registry) error {
	if swag.IsZero(m.VcExceedScoreOfxValue) { // not required
		return nil
	}

	if err := validate.MinimumInt("vc_exceed_score_of_x_value", "body", m.VcExceedScoreOfxValue, 1000, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("vc_exceed_score_of_x_value", "body", m.VcExceedScoreOfxValue, 20000, false); err != nil {
		return err
	}

	return nil
}

func (m *Ruleset) validateVcHasProductionCapacityOfxThousandValue(formats strfmt.Registry) error {
	if swag.IsZero(m.VcHasProductionCapacityOfxThousandValue) { // not required
		return nil
	}

	if err := validate.MinimumInt("vc_has_production_capacity_of_x_thousand_value", "body", m.VcHasProductionCapacityOfxThousandValue, 10, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("vc_has_production_capacity_of_x_thousand_value", "body", m.VcHasProductionCapacityOfxThousandValue, 500, false); err != nil {
		return err
	}

	return nil
}

func (m *Ruleset) validateVcHaveHighestScoreAfterxYearsValue(formats strfmt.Registry) error {
	if swag.IsZero(m.VcHaveHighestScoreAfterxYearsValue) { // not required
		return nil
	}

	if err := validate.MinimumInt("vc_have_highest_score_after_x_years_value", "body", m.VcHaveHighestScoreAfterxYearsValue, 30, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("vc_have_highest_score_after_x_years_value", "body", m.VcHaveHighestScoreAfterxYearsValue, 900, false); err != nil {
		return err
	}

	return nil
}

func (m *Ruleset) validateVcOwnsxCapitalShipsValue(formats strfmt.Registry) error {
	if swag.IsZero(m.VcOwnsxCapitalShipsValue) { // not required
		return nil
	}

	if err := validate.MinimumInt("vc_owns_x_capital_ships_value", "body", m.VcOwnsxCapitalShipsValue, 10, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("vc_owns_x_capital_ships_value", "body", m.VcOwnsxCapitalShipsValue, 300, false); err != nil {
		return err
	}

	return nil
}

func (m *Ruleset) validateVcOwnsxPercentOfPlanetsValue(formats strfmt.Registry) error {
	if swag.IsZero(m.VcOwnsxPercentOfPlanetsValue) { // not required
		return nil
	}

	if err := validate.MinimumInt("vc_owns_x_percent_of_planets_value", "body", m.VcOwnsxPercentOfPlanetsValue, 20, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("vc_owns_x_percent_of_planets_value", "body", m.VcOwnsxPercentOfPlanetsValue, 100, false); err != nil {
		return err
	}

	return nil
}

func (m *Ruleset) validateVcWinnerMustMeetxOfTheAbove(formats strfmt.Registry) error {
	if swag.IsZero(m.VcWinnerMustMeetxOfTheAbove) { // not required
		return nil
	}

	if err := validate.MinimumInt("vc_winner_must_meet_x_of_the_above", "body", m.VcWinnerMustMeetxOfTheAbove, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("vc_winner_must_meet_x_of_the_above", "body", m.VcWinnerMustMeetxOfTheAbove, 7, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this ruleset based on context it is used
func (m *Ruleset) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *Ruleset) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Ruleset) UnmarshalBinary(b []byte) error {
	var res Ruleset
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
